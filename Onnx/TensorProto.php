<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: onnx.proto3

namespace Onnx;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Tensors
 * A serialized tensor value.
 *
 * Generated from protobuf message <code>onnx.TensorProto</code>
 */
class TensorProto extends \Google\Protobuf\Internal\Message
{
    /**
     * The shape of the tensor.
     *
     * Generated from protobuf field <code>repeated int64 dims = 1;</code>
     */
    private $dims;
    /**
     * The data type of the tensor.
     * This field MUST have a valid TensorProto.DataType value
     *
     * Generated from protobuf field <code>int32 data_type = 2;</code>
     */
    protected $data_type = 0;
    /**
     * Generated from protobuf field <code>.onnx.TensorProto.Segment segment = 3;</code>
     */
    protected $segment = null;
    /**
     * For float and complex64 values
     * Complex64 tensors are encoded as a single array of floats,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
     *
     * Generated from protobuf field <code>repeated float float_data = 4 [packed = true];</code>
     */
    private $float_data;
    /**
     * For int32, uint8, int8, uint16, int16, bool, and float16 values
     * float16 values must be bit-wise converted to an uint16_t prior
     * to writing to the buffer.
     * When this field is present, the data_type field MUST be
     * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
     *
     * Generated from protobuf field <code>repeated int32 int32_data = 5 [packed = true];</code>
     */
    private $int32_data;
    /**
     * For strings.
     * Each element of string_data is a UTF-8 encoded Unicode
     * string. No trailing null, no leading BOM. The protobuf "string"
     * scalar type is not used to match ML community conventions.
     * When this field is present, the data_type field MUST be STRING
     *
     * Generated from protobuf field <code>repeated bytes string_data = 6;</code>
     */
    private $string_data;
    /**
     * For int64.
     * When this field is present, the data_type field MUST be INT64
     *
     * Generated from protobuf field <code>repeated int64 int64_data = 7 [packed = true];</code>
     */
    private $int64_data;
    /**
     * Optionally, a name for the tensor.
     *
     * Generated from protobuf field <code>string name = 8;</code>
     */
    protected $name = '';
    /**
     * A human-readable documentation for this tensor. Markdown is allowed.
     *
     * Generated from protobuf field <code>string doc_string = 12;</code>
     */
    protected $doc_string = '';
    /**
     * Serializations can either use one of the fields above, or use this
     * raw bytes field. The only exception is the string case, where one is
     * required to store the content in the repeated bytes string_data field.
     * When this raw_data field is used to store tensor value, elements MUST
     * be stored in as fixed-width, little-endian order.
     * Floating-point data types MUST be stored in IEEE 754 format.
     * Complex64 elements must be written as two consecutive FLOAT values, real component first.
     * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
     * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
     * Note: the advantage of specific field rather than the raw_data field is
     * that in some cases (e.g. int data), protobuf does a better packing via
     * variable length storage, and may lead to smaller binary footprint.
     * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
     *
     * Generated from protobuf field <code>bytes raw_data = 9;</code>
     */
    protected $raw_data = '';
    /**
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     *                           protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     *
     * Generated from protobuf field <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
     */
    private $external_data;
    /**
     * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
     *
     * Generated from protobuf field <code>.onnx.TensorProto.DataLocation data_location = 14;</code>
     */
    protected $data_location = 0;
    /**
     * For double
     * Complex128 tensors are encoded as a single array of doubles,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
     *
     * Generated from protobuf field <code>repeated double double_data = 10 [packed = true];</code>
     */
    private $double_data;
    /**
     * For uint64 and uint32 values
     * When this field is present, the data_type field MUST be
     * UINT32 or UINT64
     *
     * Generated from protobuf field <code>repeated uint64 uint64_data = 11 [packed = true];</code>
     */
    private $uint64_data;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type array<int>|array<string>|\Google\Protobuf\Internal\RepeatedField $dims
     *           The shape of the tensor.
     *     @type int $data_type
     *           The data type of the tensor.
     *           This field MUST have a valid TensorProto.DataType value
     *     @type \Onnx\TensorProto\Segment $segment
     *     @type array<float>|\Google\Protobuf\Internal\RepeatedField $float_data
     *           For float and complex64 values
     *           Complex64 tensors are encoded as a single array of floats,
     *           with the real components appearing in odd numbered positions,
     *           and the corresponding imaginary component appearing in the
     *           subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     *           is encoded as [1.0, 2.0 ,3.0 ,4.0]
     *           When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
     *     @type array<int>|\Google\Protobuf\Internal\RepeatedField $int32_data
     *           For int32, uint8, int8, uint16, int16, bool, and float16 values
     *           float16 values must be bit-wise converted to an uint16_t prior
     *           to writing to the buffer.
     *           When this field is present, the data_type field MUST be
     *           INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
     *     @type array<string>|\Google\Protobuf\Internal\RepeatedField $string_data
     *           For strings.
     *           Each element of string_data is a UTF-8 encoded Unicode
     *           string. No trailing null, no leading BOM. The protobuf "string"
     *           scalar type is not used to match ML community conventions.
     *           When this field is present, the data_type field MUST be STRING
     *     @type array<int>|array<string>|\Google\Protobuf\Internal\RepeatedField $int64_data
     *           For int64.
     *           When this field is present, the data_type field MUST be INT64
     *     @type string $name
     *           Optionally, a name for the tensor.
     *     @type string $doc_string
     *           A human-readable documentation for this tensor. Markdown is allowed.
     *     @type string $raw_data
     *           Serializations can either use one of the fields above, or use this
     *           raw bytes field. The only exception is the string case, where one is
     *           required to store the content in the repeated bytes string_data field.
     *           When this raw_data field is used to store tensor value, elements MUST
     *           be stored in as fixed-width, little-endian order.
     *           Floating-point data types MUST be stored in IEEE 754 format.
     *           Complex64 elements must be written as two consecutive FLOAT values, real component first.
     *           Complex128 elements must be written as two consecutive DOUBLE values, real component first.
     *           Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
     *           Note: the advantage of specific field rather than the raw_data field is
     *           that in some cases (e.g. int data), protobuf does a better packing via
     *           variable length storage, and may lead to smaller binary footprint.
     *           When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
     *     @type array<\Onnx\StringStringEntryProto>|\Google\Protobuf\Internal\RepeatedField $external_data
     *           Data can be stored inside the protobuf file using type-specific fields or raw_data.
     *           Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     *           external_data stores key-value pairs describing data location. Recognized keys are:
     *           - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     *                                     protobuf model was stored
     *           - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     *                                   Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     *           - "length" (optional) - number of bytes containing data. Integer stored as string.
     *           - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     *     @type int $data_location
     *           If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
     *     @type array<float>|\Google\Protobuf\Internal\RepeatedField $double_data
     *           For double
     *           Complex128 tensors are encoded as a single array of doubles,
     *           with the real components appearing in odd numbered positions,
     *           and the corresponding imaginary component appearing in the
     *           subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     *           is encoded as [1.0, 2.0 ,3.0 ,4.0]
     *           When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
     *     @type array<int>|array<string>|\Google\Protobuf\Internal\RepeatedField $uint64_data
     *           For uint64 and uint32 values
     *           When this field is present, the data_type field MUST be
     *           UINT32 or UINT64
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Onnx::initOnce();
        parent::__construct($data);
    }

    /**
     * The shape of the tensor.
     *
     * Generated from protobuf field <code>repeated int64 dims = 1;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getDims()
    {
        return $this->dims;
    }

    /**
     * The shape of the tensor.
     *
     * Generated from protobuf field <code>repeated int64 dims = 1;</code>
     * @param array<int>|array<string>|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setDims($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::INT64);
        $this->dims = $arr;

        return $this;
    }

    /**
     * The data type of the tensor.
     * This field MUST have a valid TensorProto.DataType value
     *
     * Generated from protobuf field <code>int32 data_type = 2;</code>
     * @return int
     */
    public function getDataType()
    {
        return $this->data_type;
    }

    /**
     * The data type of the tensor.
     * This field MUST have a valid TensorProto.DataType value
     *
     * Generated from protobuf field <code>int32 data_type = 2;</code>
     * @param int $var
     * @return $this
     */
    public function setDataType($var)
    {
        GPBUtil::checkInt32($var);
        $this->data_type = $var;

        return $this;
    }

    /**
     * Generated from protobuf field <code>.onnx.TensorProto.Segment segment = 3;</code>
     * @return \Onnx\TensorProto\Segment|null
     */
    public function getSegment()
    {
        return $this->segment;
    }

    public function hasSegment()
    {
        return isset($this->segment);
    }

    public function clearSegment()
    {
        unset($this->segment);
    }

    /**
     * Generated from protobuf field <code>.onnx.TensorProto.Segment segment = 3;</code>
     * @param \Onnx\TensorProto\Segment $var
     * @return $this
     */
    public function setSegment($var)
    {
        GPBUtil::checkMessage($var, \Onnx\TensorProto\Segment::class);
        $this->segment = $var;

        return $this;
    }

    /**
     * For float and complex64 values
     * Complex64 tensors are encoded as a single array of floats,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
     *
     * Generated from protobuf field <code>repeated float float_data = 4 [packed = true];</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getFloatData()
    {
        return $this->float_data;
    }

    /**
     * For float and complex64 values
     * Complex64 tensors are encoded as a single array of floats,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
     *
     * Generated from protobuf field <code>repeated float float_data = 4 [packed = true];</code>
     * @param array<float>|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setFloatData($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::FLOAT);
        $this->float_data = $arr;

        return $this;
    }

    /**
     * For int32, uint8, int8, uint16, int16, bool, and float16 values
     * float16 values must be bit-wise converted to an uint16_t prior
     * to writing to the buffer.
     * When this field is present, the data_type field MUST be
     * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
     *
     * Generated from protobuf field <code>repeated int32 int32_data = 5 [packed = true];</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getInt32Data()
    {
        return $this->int32_data;
    }

    /**
     * For int32, uint8, int8, uint16, int16, bool, and float16 values
     * float16 values must be bit-wise converted to an uint16_t prior
     * to writing to the buffer.
     * When this field is present, the data_type field MUST be
     * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
     *
     * Generated from protobuf field <code>repeated int32 int32_data = 5 [packed = true];</code>
     * @param array<int>|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setInt32Data($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::INT32);
        $this->int32_data = $arr;

        return $this;
    }

    /**
     * For strings.
     * Each element of string_data is a UTF-8 encoded Unicode
     * string. No trailing null, no leading BOM. The protobuf "string"
     * scalar type is not used to match ML community conventions.
     * When this field is present, the data_type field MUST be STRING
     *
     * Generated from protobuf field <code>repeated bytes string_data = 6;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getStringData()
    {
        return $this->string_data;
    }

    /**
     * For strings.
     * Each element of string_data is a UTF-8 encoded Unicode
     * string. No trailing null, no leading BOM. The protobuf "string"
     * scalar type is not used to match ML community conventions.
     * When this field is present, the data_type field MUST be STRING
     *
     * Generated from protobuf field <code>repeated bytes string_data = 6;</code>
     * @param array<string>|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setStringData($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::BYTES);
        $this->string_data = $arr;

        return $this;
    }

    /**
     * For int64.
     * When this field is present, the data_type field MUST be INT64
     *
     * Generated from protobuf field <code>repeated int64 int64_data = 7 [packed = true];</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getInt64Data()
    {
        return $this->int64_data;
    }

    /**
     * For int64.
     * When this field is present, the data_type field MUST be INT64
     *
     * Generated from protobuf field <code>repeated int64 int64_data = 7 [packed = true];</code>
     * @param array<int>|array<string>|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setInt64Data($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::INT64);
        $this->int64_data = $arr;

        return $this;
    }

    /**
     * Optionally, a name for the tensor.
     *
     * Generated from protobuf field <code>string name = 8;</code>
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * Optionally, a name for the tensor.
     *
     * Generated from protobuf field <code>string name = 8;</code>
     * @param string $var
     * @return $this
     */
    public function setName($var)
    {
        GPBUtil::checkString($var, True);
        $this->name = $var;

        return $this;
    }

    /**
     * A human-readable documentation for this tensor. Markdown is allowed.
     *
     * Generated from protobuf field <code>string doc_string = 12;</code>
     * @return string
     */
    public function getDocString()
    {
        return $this->doc_string;
    }

    /**
     * A human-readable documentation for this tensor. Markdown is allowed.
     *
     * Generated from protobuf field <code>string doc_string = 12;</code>
     * @param string $var
     * @return $this
     */
    public function setDocString($var)
    {
        GPBUtil::checkString($var, True);
        $this->doc_string = $var;

        return $this;
    }

    /**
     * Serializations can either use one of the fields above, or use this
     * raw bytes field. The only exception is the string case, where one is
     * required to store the content in the repeated bytes string_data field.
     * When this raw_data field is used to store tensor value, elements MUST
     * be stored in as fixed-width, little-endian order.
     * Floating-point data types MUST be stored in IEEE 754 format.
     * Complex64 elements must be written as two consecutive FLOAT values, real component first.
     * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
     * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
     * Note: the advantage of specific field rather than the raw_data field is
     * that in some cases (e.g. int data), protobuf does a better packing via
     * variable length storage, and may lead to smaller binary footprint.
     * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
     *
     * Generated from protobuf field <code>bytes raw_data = 9;</code>
     * @return string
     */
    public function getRawData()
    {
        return $this->raw_data;
    }

    /**
     * Serializations can either use one of the fields above, or use this
     * raw bytes field. The only exception is the string case, where one is
     * required to store the content in the repeated bytes string_data field.
     * When this raw_data field is used to store tensor value, elements MUST
     * be stored in as fixed-width, little-endian order.
     * Floating-point data types MUST be stored in IEEE 754 format.
     * Complex64 elements must be written as two consecutive FLOAT values, real component first.
     * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
     * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
     * Note: the advantage of specific field rather than the raw_data field is
     * that in some cases (e.g. int data), protobuf does a better packing via
     * variable length storage, and may lead to smaller binary footprint.
     * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
     *
     * Generated from protobuf field <code>bytes raw_data = 9;</code>
     * @param string $var
     * @return $this
     */
    public function setRawData($var)
    {
        GPBUtil::checkString($var, False);
        $this->raw_data = $var;

        return $this;
    }

    /**
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     *                           protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     *
     * Generated from protobuf field <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getExternalData()
    {
        return $this->external_data;
    }

    /**
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     *                           protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     *
     * Generated from protobuf field <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
     * @param array<\Onnx\StringStringEntryProto>|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setExternalData($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Onnx\StringStringEntryProto::class);
        $this->external_data = $arr;

        return $this;
    }

    /**
     * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
     *
     * Generated from protobuf field <code>.onnx.TensorProto.DataLocation data_location = 14;</code>
     * @return int
     */
    public function getDataLocation()
    {
        return $this->data_location;
    }

    /**
     * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
     *
     * Generated from protobuf field <code>.onnx.TensorProto.DataLocation data_location = 14;</code>
     * @param int $var
     * @return $this
     */
    public function setDataLocation($var)
    {
        GPBUtil::checkEnum($var, \Onnx\TensorProto\DataLocation::class);
        $this->data_location = $var;

        return $this;
    }

    /**
     * For double
     * Complex128 tensors are encoded as a single array of doubles,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
     *
     * Generated from protobuf field <code>repeated double double_data = 10 [packed = true];</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getDoubleData()
    {
        return $this->double_data;
    }

    /**
     * For double
     * Complex128 tensors are encoded as a single array of doubles,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
     *
     * Generated from protobuf field <code>repeated double double_data = 10 [packed = true];</code>
     * @param array<float>|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setDoubleData($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::DOUBLE);
        $this->double_data = $arr;

        return $this;
    }

    /**
     * For uint64 and uint32 values
     * When this field is present, the data_type field MUST be
     * UINT32 or UINT64
     *
     * Generated from protobuf field <code>repeated uint64 uint64_data = 11 [packed = true];</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getUint64Data()
    {
        return $this->uint64_data;
    }

    /**
     * For uint64 and uint32 values
     * When this field is present, the data_type field MUST be
     * UINT32 or UINT64
     *
     * Generated from protobuf field <code>repeated uint64 uint64_data = 11 [packed = true];</code>
     * @param array<int>|array<string>|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setUint64Data($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::UINT64);
        $this->uint64_data = $arr;

        return $this;
    }

}

