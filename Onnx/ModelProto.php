<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: onnx.proto3

namespace Onnx;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Models
 * ModelProto is a top-level file/container format for bundling a ML model and
 * associating its computation graph with metadata.
 * The semantics of the model are described by the associated GraphProto's.
 *
 * Generated from protobuf message <code>onnx.ModelProto</code>
 */
class ModelProto extends \Google\Protobuf\Internal\Message
{
    /**
     * The version of the IR this model targets. See Version enum above.
     * This field MUST be present.
     *
     * Generated from protobuf field <code>int64 ir_version = 1;</code>
     */
    protected $ir_version = 0;
    /**
     * The OperatorSets this model relies on.
     * All ModelProtos MUST have at least one entry that
     * specifies which version of the ONNX OperatorSet is
     * being imported.
     * All nodes in the ModelProto's graph will bind against the operator
     * with the same-domain/same-op_type operator with the HIGHEST version
     * in the referenced operator sets.
     *
     * Generated from protobuf field <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
     */
    private $opset_import;
    /**
     * The name of the framework or tool used to generate this model.
     * This field SHOULD be present to indicate which implementation/tool/framework
     * emitted the model.
     *
     * Generated from protobuf field <code>string producer_name = 2;</code>
     */
    protected $producer_name = '';
    /**
     * The version of the framework or tool used to generate this model.
     * This field SHOULD be present to indicate which implementation/tool/framework
     * emitted the model.
     *
     * Generated from protobuf field <code>string producer_version = 3;</code>
     */
    protected $producer_version = '';
    /**
     * Domain name of the model.
     * We use reverse domain names as name space indicators. For example:
     * `com.facebook.fair` or `com.microsoft.cognitiveservices`
     * Together with `model_version` and GraphProto.name, this forms the unique identity of
     * the graph.
     *
     * Generated from protobuf field <code>string domain = 4;</code>
     */
    protected $domain = '';
    /**
     * The version of the graph encoded. See Version enum below.
     *
     * Generated from protobuf field <code>int64 model_version = 5;</code>
     */
    protected $model_version = 0;
    /**
     * A human-readable documentation for this model. Markdown is allowed.
     *
     * Generated from protobuf field <code>string doc_string = 6;</code>
     */
    protected $doc_string = '';
    /**
     * The parameterized graph that is evaluated to execute the model.
     *
     * Generated from protobuf field <code>.onnx.GraphProto graph = 7;</code>
     */
    protected $graph = null;
    /**
     * Named metadata values; keys should be distinct.
     *
     * Generated from protobuf field <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
     */
    private $metadata_props;
    /**
     * Training-specific information. Sequentially executing all stored
     * `TrainingInfoProto.algorithm`s and assigning their outputs following
     * the corresponding `TrainingInfoProto.update_binding`s is one training
     * iteration. Similarly, to initialize the model
     * (as if training hasn't happened), the user should sequentially execute
     * all stored `TrainingInfoProto.initialization`s and assigns their outputs
     * using `TrainingInfoProto.initialization_binding`s.
     * If this field is empty, the training behavior of the model is undefined.
     *
     * Generated from protobuf field <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
     */
    private $training_info;
    /**
     * A list of function protos local to the model.
     * Name of the function "FunctionProto.name" should be unique within the domain "FunctionProto.domain".
     * In case of any conflicts the behavior (whether the model local functions are given higher priority,
     * or standard opserator sets are given higher priotity or this is treated as error) is defined by 
     * the runtimes.
     * 
     * The operator sets imported by FunctionProto should be compatible with the ones
     * imported by ModelProto and other model local FunctionProtos. 
     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto 
     * or by 2 FunctionProtos then versions for the operator set may be different but, 
     * the operator schema returned for op_type, domain, version combination
     * for both the versions should be same for every node in the function body.
     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
     * is not allowed.
     *
     * Generated from protobuf field <code>repeated .onnx.FunctionProto functions = 25;</code>
     */
    private $functions;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type int|string $ir_version
     *           The version of the IR this model targets. See Version enum above.
     *           This field MUST be present.
     *     @type array<\Onnx\OperatorSetIdProto>|\Google\Protobuf\Internal\RepeatedField $opset_import
     *           The OperatorSets this model relies on.
     *           All ModelProtos MUST have at least one entry that
     *           specifies which version of the ONNX OperatorSet is
     *           being imported.
     *           All nodes in the ModelProto's graph will bind against the operator
     *           with the same-domain/same-op_type operator with the HIGHEST version
     *           in the referenced operator sets.
     *     @type string $producer_name
     *           The name of the framework or tool used to generate this model.
     *           This field SHOULD be present to indicate which implementation/tool/framework
     *           emitted the model.
     *     @type string $producer_version
     *           The version of the framework or tool used to generate this model.
     *           This field SHOULD be present to indicate which implementation/tool/framework
     *           emitted the model.
     *     @type string $domain
     *           Domain name of the model.
     *           We use reverse domain names as name space indicators. For example:
     *           `com.facebook.fair` or `com.microsoft.cognitiveservices`
     *           Together with `model_version` and GraphProto.name, this forms the unique identity of
     *           the graph.
     *     @type int|string $model_version
     *           The version of the graph encoded. See Version enum below.
     *     @type string $doc_string
     *           A human-readable documentation for this model. Markdown is allowed.
     *     @type \Onnx\GraphProto $graph
     *           The parameterized graph that is evaluated to execute the model.
     *     @type array<\Onnx\StringStringEntryProto>|\Google\Protobuf\Internal\RepeatedField $metadata_props
     *           Named metadata values; keys should be distinct.
     *     @type array<\Onnx\TrainingInfoProto>|\Google\Protobuf\Internal\RepeatedField $training_info
     *           Training-specific information. Sequentially executing all stored
     *           `TrainingInfoProto.algorithm`s and assigning their outputs following
     *           the corresponding `TrainingInfoProto.update_binding`s is one training
     *           iteration. Similarly, to initialize the model
     *           (as if training hasn't happened), the user should sequentially execute
     *           all stored `TrainingInfoProto.initialization`s and assigns their outputs
     *           using `TrainingInfoProto.initialization_binding`s.
     *           If this field is empty, the training behavior of the model is undefined.
     *     @type array<\Onnx\FunctionProto>|\Google\Protobuf\Internal\RepeatedField $functions
     *           A list of function protos local to the model.
     *           Name of the function "FunctionProto.name" should be unique within the domain "FunctionProto.domain".
     *           In case of any conflicts the behavior (whether the model local functions are given higher priority,
     *           or standard opserator sets are given higher priotity or this is treated as error) is defined by 
     *           the runtimes.
     *           
     *           The operator sets imported by FunctionProto should be compatible with the ones
     *           imported by ModelProto and other model local FunctionProtos. 
     *           Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto 
     *           or by 2 FunctionProtos then versions for the operator set may be different but, 
     *           the operator schema returned for op_type, domain, version combination
     *           for both the versions should be same for every node in the function body.
     *           One FunctionProto can reference other FunctionProto in the model, however, recursive reference
     *           is not allowed.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Onnx::initOnce();
        parent::__construct($data);
    }

    /**
     * The version of the IR this model targets. See Version enum above.
     * This field MUST be present.
     *
     * Generated from protobuf field <code>int64 ir_version = 1;</code>
     * @return int|string
     */
    public function getIrVersion()
    {
        return $this->ir_version;
    }

    /**
     * The version of the IR this model targets. See Version enum above.
     * This field MUST be present.
     *
     * Generated from protobuf field <code>int64 ir_version = 1;</code>
     * @param int|string $var
     * @return $this
     */
    public function setIrVersion($var)
    {
        GPBUtil::checkInt64($var);
        $this->ir_version = $var;

        return $this;
    }

    /**
     * The OperatorSets this model relies on.
     * All ModelProtos MUST have at least one entry that
     * specifies which version of the ONNX OperatorSet is
     * being imported.
     * All nodes in the ModelProto's graph will bind against the operator
     * with the same-domain/same-op_type operator with the HIGHEST version
     * in the referenced operator sets.
     *
     * Generated from protobuf field <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getOpsetImport()
    {
        return $this->opset_import;
    }

    /**
     * The OperatorSets this model relies on.
     * All ModelProtos MUST have at least one entry that
     * specifies which version of the ONNX OperatorSet is
     * being imported.
     * All nodes in the ModelProto's graph will bind against the operator
     * with the same-domain/same-op_type operator with the HIGHEST version
     * in the referenced operator sets.
     *
     * Generated from protobuf field <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
     * @param array<\Onnx\OperatorSetIdProto>|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setOpsetImport($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Onnx\OperatorSetIdProto::class);
        $this->opset_import = $arr;

        return $this;
    }

    /**
     * The name of the framework or tool used to generate this model.
     * This field SHOULD be present to indicate which implementation/tool/framework
     * emitted the model.
     *
     * Generated from protobuf field <code>string producer_name = 2;</code>
     * @return string
     */
    public function getProducerName()
    {
        return $this->producer_name;
    }

    /**
     * The name of the framework or tool used to generate this model.
     * This field SHOULD be present to indicate which implementation/tool/framework
     * emitted the model.
     *
     * Generated from protobuf field <code>string producer_name = 2;</code>
     * @param string $var
     * @return $this
     */
    public function setProducerName($var)
    {
        GPBUtil::checkString($var, True);
        $this->producer_name = $var;

        return $this;
    }

    /**
     * The version of the framework or tool used to generate this model.
     * This field SHOULD be present to indicate which implementation/tool/framework
     * emitted the model.
     *
     * Generated from protobuf field <code>string producer_version = 3;</code>
     * @return string
     */
    public function getProducerVersion()
    {
        return $this->producer_version;
    }

    /**
     * The version of the framework or tool used to generate this model.
     * This field SHOULD be present to indicate which implementation/tool/framework
     * emitted the model.
     *
     * Generated from protobuf field <code>string producer_version = 3;</code>
     * @param string $var
     * @return $this
     */
    public function setProducerVersion($var)
    {
        GPBUtil::checkString($var, True);
        $this->producer_version = $var;

        return $this;
    }

    /**
     * Domain name of the model.
     * We use reverse domain names as name space indicators. For example:
     * `com.facebook.fair` or `com.microsoft.cognitiveservices`
     * Together with `model_version` and GraphProto.name, this forms the unique identity of
     * the graph.
     *
     * Generated from protobuf field <code>string domain = 4;</code>
     * @return string
     */
    public function getDomain()
    {
        return $this->domain;
    }

    /**
     * Domain name of the model.
     * We use reverse domain names as name space indicators. For example:
     * `com.facebook.fair` or `com.microsoft.cognitiveservices`
     * Together with `model_version` and GraphProto.name, this forms the unique identity of
     * the graph.
     *
     * Generated from protobuf field <code>string domain = 4;</code>
     * @param string $var
     * @return $this
     */
    public function setDomain($var)
    {
        GPBUtil::checkString($var, True);
        $this->domain = $var;

        return $this;
    }

    /**
     * The version of the graph encoded. See Version enum below.
     *
     * Generated from protobuf field <code>int64 model_version = 5;</code>
     * @return int|string
     */
    public function getModelVersion()
    {
        return $this->model_version;
    }

    /**
     * The version of the graph encoded. See Version enum below.
     *
     * Generated from protobuf field <code>int64 model_version = 5;</code>
     * @param int|string $var
     * @return $this
     */
    public function setModelVersion($var)
    {
        GPBUtil::checkInt64($var);
        $this->model_version = $var;

        return $this;
    }

    /**
     * A human-readable documentation for this model. Markdown is allowed.
     *
     * Generated from protobuf field <code>string doc_string = 6;</code>
     * @return string
     */
    public function getDocString()
    {
        return $this->doc_string;
    }

    /**
     * A human-readable documentation for this model. Markdown is allowed.
     *
     * Generated from protobuf field <code>string doc_string = 6;</code>
     * @param string $var
     * @return $this
     */
    public function setDocString($var)
    {
        GPBUtil::checkString($var, True);
        $this->doc_string = $var;

        return $this;
    }

    /**
     * The parameterized graph that is evaluated to execute the model.
     *
     * Generated from protobuf field <code>.onnx.GraphProto graph = 7;</code>
     * @return \Onnx\GraphProto|null
     */
    public function getGraph()
    {
        return $this->graph;
    }

    public function hasGraph()
    {
        return isset($this->graph);
    }

    public function clearGraph()
    {
        unset($this->graph);
    }

    /**
     * The parameterized graph that is evaluated to execute the model.
     *
     * Generated from protobuf field <code>.onnx.GraphProto graph = 7;</code>
     * @param \Onnx\GraphProto $var
     * @return $this
     */
    public function setGraph($var)
    {
        GPBUtil::checkMessage($var, \Onnx\GraphProto::class);
        $this->graph = $var;

        return $this;
    }

    /**
     * Named metadata values; keys should be distinct.
     *
     * Generated from protobuf field <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getMetadataProps()
    {
        return $this->metadata_props;
    }

    /**
     * Named metadata values; keys should be distinct.
     *
     * Generated from protobuf field <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
     * @param array<\Onnx\StringStringEntryProto>|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setMetadataProps($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Onnx\StringStringEntryProto::class);
        $this->metadata_props = $arr;

        return $this;
    }

    /**
     * Training-specific information. Sequentially executing all stored
     * `TrainingInfoProto.algorithm`s and assigning their outputs following
     * the corresponding `TrainingInfoProto.update_binding`s is one training
     * iteration. Similarly, to initialize the model
     * (as if training hasn't happened), the user should sequentially execute
     * all stored `TrainingInfoProto.initialization`s and assigns their outputs
     * using `TrainingInfoProto.initialization_binding`s.
     * If this field is empty, the training behavior of the model is undefined.
     *
     * Generated from protobuf field <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getTrainingInfo()
    {
        return $this->training_info;
    }

    /**
     * Training-specific information. Sequentially executing all stored
     * `TrainingInfoProto.algorithm`s and assigning their outputs following
     * the corresponding `TrainingInfoProto.update_binding`s is one training
     * iteration. Similarly, to initialize the model
     * (as if training hasn't happened), the user should sequentially execute
     * all stored `TrainingInfoProto.initialization`s and assigns their outputs
     * using `TrainingInfoProto.initialization_binding`s.
     * If this field is empty, the training behavior of the model is undefined.
     *
     * Generated from protobuf field <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
     * @param array<\Onnx\TrainingInfoProto>|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setTrainingInfo($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Onnx\TrainingInfoProto::class);
        $this->training_info = $arr;

        return $this;
    }

    /**
     * A list of function protos local to the model.
     * Name of the function "FunctionProto.name" should be unique within the domain "FunctionProto.domain".
     * In case of any conflicts the behavior (whether the model local functions are given higher priority,
     * or standard opserator sets are given higher priotity or this is treated as error) is defined by 
     * the runtimes.
     * 
     * The operator sets imported by FunctionProto should be compatible with the ones
     * imported by ModelProto and other model local FunctionProtos. 
     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto 
     * or by 2 FunctionProtos then versions for the operator set may be different but, 
     * the operator schema returned for op_type, domain, version combination
     * for both the versions should be same for every node in the function body.
     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
     * is not allowed.
     *
     * Generated from protobuf field <code>repeated .onnx.FunctionProto functions = 25;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getFunctions()
    {
        return $this->functions;
    }

    /**
     * A list of function protos local to the model.
     * Name of the function "FunctionProto.name" should be unique within the domain "FunctionProto.domain".
     * In case of any conflicts the behavior (whether the model local functions are given higher priority,
     * or standard opserator sets are given higher priotity or this is treated as error) is defined by 
     * the runtimes.
     * 
     * The operator sets imported by FunctionProto should be compatible with the ones
     * imported by ModelProto and other model local FunctionProtos. 
     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto 
     * or by 2 FunctionProtos then versions for the operator set may be different but, 
     * the operator schema returned for op_type, domain, version combination
     * for both the versions should be same for every node in the function body.
     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
     * is not allowed.
     *
     * Generated from protobuf field <code>repeated .onnx.FunctionProto functions = 25;</code>
     * @param array<\Onnx\FunctionProto>|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setFunctions($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Onnx\FunctionProto::class);
        $this->functions = $arr;

        return $this;
    }

}

